<?php

namespace App\Services\GameSources\Forebet;

use App\Models\Competition;
use App\Models\Country;
use App\Models\GameScore;
use App\Models\GameSource;
use App\Models\Referee;
use App\Models\Season;
use Illuminate\Support\Str;

/**
 * Class BaseHandlerController
 * 
 * A base controller for handling Forebet game sources.
 * It provides common properties and initialization logic.
 */
trait ForebetInitializationTrait
{
    /**
     * @var string The base URL for the Forebet source.
     */
    public $url;

    /**
     * @var array Configuration settings for the handler.
     */
    public $config;

    /**
     * @var string The source URL for Forebet.
     */
    public $sourceUrl;

    /**
     * @var array Request preferences for HTTP requests.
     */
    public $reqPrefs = array();

    /**
     * @var int The ID of the Forebet game source.
     */
    public $sourceId;

    /**
     * Constructor for ForebetInitializationTrait.
     */
    public function __construct()
    {
        $this->initialize();
    }

    function matchMessage($message, $status = 422)
    {
        $arr = ['message' => $message];
        if (request()->without_response) return $arr;
        return response($arr, $status);
    }

    /**
     * Initialize the Forebet game source handler.
     * This method sets up the configuration, source URL, request preferences,
     * and updates or creates the GameSource record in the database.
     */
    public function initialize()
    {
        // Set the base URL for the Forebet source
        $this->config['sourceUrl'] = 'https://www.forebet.com/';

        // Assign the source URL
        $this->sourceUrl = $this->config['sourceUrl'];

        // Set the HTTP method for requests
        $this->reqPrefs['http']['method'] = 'GET';

        // Update or create the GameSource record in the database
        $this->sourceId = GameSource::updateOrCreate(
            [
                'url' => $this->sourceUrl,
            ],
            [
                'name' => 'Mathematical football predictions /forebets/ and football statistics',
                'url' => $this->sourceUrl,
                'description' => 'Forebet presents mathematical football predictions generated by computer algorithm on the basis of statistics. Predictions, statistics, live-score, match previews and detailed analysis for more than 700 football leagues',
                'priority_number' => 2,
                'status_id' => activeStatusId(),
                'user_id' => auth()->id() ?? 0,
            ]
        )->id ?? 0;
    }

    private function storeScores($game, $score)
    {

        $full_time_results = $score['full_time_results'];

        if (Str::contains($full_time_results, ':')) return false;

        $winner = isset($score['postponed']) ? Str::upper('postponed') : null;

        $home_scores_full_time = null;
        $away_scores_full_time = null;

        if (Str::contains($full_time_results, '-')) {
            $arr = explode('-', $full_time_results);
            $home_scores_full_time = trim($arr[0]);
            $away_scores_full_time = trim($arr[1]);

            if ($home_scores_full_time > $away_scores_full_time)
                $winner = 'HOME_TEAM';
            elseif ($home_scores_full_time == $away_scores_full_time)
                $winner = 'DRAW';
            elseif ($home_scores_full_time < $away_scores_full_time)
                $winner = 'AWAY_TEAM';
        }

        $data = [
            'game_id' => $game->id,
            'winner' => $winner,
            'duration' => null,

            'home_scores_full_time' => $home_scores_full_time,
            'away_scores_full_time' => $away_scores_full_time,
        ];

        if (isset($score['half_time_results'])) {

            $half_time_results = $score['half_time_results'];

            if (Str::contains($half_time_results, '-')) {
                $arr = explode('-', $half_time_results);
                $home_scores_half_time = trim($arr[0]);
                $away_scores_half_time = trim($arr[1]);

                $data['home_scores_half_time'] = $home_scores_half_time;
                $data['away_scores_half_time'] = $away_scores_half_time;
            }
        }

        $results_status = 0;
        if ($winner) {
            $score = GameScore::updateOrCreate(
                [
                    'game_id' => $game->id
                ],
                $data
            );

            $results_status = 2;
            if ($game->results_status != 2) {

                if (isset($data['home_scores_half_time']) && $data['home_scores_half_time'] >= 0) {
                    $results_status = 2;
                    $game->update(['results_status' => $results_status, 'status' => 'FINISHED']);
                }
                // postponed
                else if ($score->winner == Str::upper('postponed')) {
                    $results_status = 2;
                    $game->update(['results_status' => $results_status, 'status' => Str::upper('postponed')]);
                }

                // Avoid overwriting
                else if ($score->home_scores_half_time == null) {
                    $results_status = 1;
                    $game->update(['results_status' => $results_status, 'status' => 'FINISHED']);
                }
            }
        }

        return $results_status;
    }

    private function syncReferees($game, $match)
    {

        if (isset($match->referees)) {

            $referees = $match->referees;
            $refsArr = [];
            foreach ($referees as $referee) {

                $country = Country::where('name', $referee->nationality)->first();

                $ref = Referee::updateOrCreate([
                    'name' => $referee->name,
                    'type' => $referee->type,
                    'country_id' => $country->id ?? 0,
                ]);

                if ($ref) {
                    $refsArr[] = $ref->id;
                }
            }

            $game->referees()->sync($refsArr);
        }
    }

    function prepareFetch($competition_id, $season_id = null)
    {

        if ($season_id) {
            $season = Season::find($season_id);
        } else {
            $season = Season::where('competition_id', $competition_id)->where('is_current', true)->first();
        }

        $season_str = null;
        if ($season)
            $season_str = Str::before($season->start_date, '-') . '-' . Str::before($season->end_date, '-');

        $competition = Competition::whereHas('gameSources', function ($q) use ($competition_id) {
            $q->where('competition_id', $competition_id);
        })->first();

        if (!$competition) {
            $message = 'Competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;

            return response(['message' => $message], 404);
        }

        // Access the source_id value for the pivot
        $source = $competition->gameSources()->where(function ($q) use ($competition_id) {
            $q->where('game_source_id', $this->sourceId)->where('competition_id', $competition_id);
        })->first()->pivot;

        if (!$source) {
            $message = 'Source for competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 404);
        }

        if (!$source->is_subscribed) {
            $message = 'Source #' . $source->source_id . ' not subscribed.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 402);
        }

        return ['message' => true, 'data' => [$competition, $season, $source, $season_str]];
    }
}
